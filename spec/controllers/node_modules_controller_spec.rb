# frozen_string_literal: true

require 'rails_helper'
require 'me_salva/permalinks/builder'

RSpec.describe NodeModulesController, type: :controller do
  include ContentStructureAssertionHelper
  include RelationshipOrderAssertionHelper
  include PermalinkAssertionHelper
  include PermalinkBuildAssertionHelper

  let(:valid_attributes) { FactoryBot.attributes_for(:node_module) }
  let(:invalid_attributes) do
    FactoryBot.attributes_for(:node_module, name: '')
  end
  let!(:node_module) { create(:node_module, valid_attributes) }

  describe 'POST #create' do
    context 'as admin' do
      before { admin_session }
      context 'with valid params' do
        it 'creates a new NodeModule' do
          expect do
            post :create, params: valid_attributes
          end.to change(NodeModule, :count).by(1)
          node_module = NodeModule.last

          assert_jsonapi_response(:created, node_module, NodeModuleSerializer)
          expect(node_module.created_by).to eq(admin.uid)
          assert_response_does_not_have_included_relationships
          assert_presence_of_relationships(
            parsed_response['data'], %w[media items nodes]
          )
        end
        it_behaves_like 'a controller with a permitted parameter',
                        [{ attribute: 'relevancy',
                           create_val: 1, update_val: 2 },
                         { attribute: 'position',
                           create_val: 2, update_val: 3 }]
      end
      context 'with invalid params' do
        it 'returns http code 422 unprocessable entity' do
          post :create, params: invalid_attributes

          expect(assigns(:node_module)).to be_a_new(NodeModule)
          expect(response).to have_http_status(:unprocessable_entity)
        end
      end
    end
    context 'as user' do
      context 'with valid params' do
        before { user_session }
        it 'returns http unauthorized' do
          post :create, params: valid_attributes

          expect(response).to have_http_status(:unauthorized)
        end
      end
    end
  end

  describe 'PUT #update' do
    let(:new_attributes) do
      FactoryBot.attributes_for(:node_module, name: 'other node module')
    end

    context 'as admin' do
      before { admin_session }
      context 'with valid params' do
        it 'updates the requested node_module' do
          put :update, params: { id: node_module, name: 'other node module' }

          node_module.reload
          expect(node_module.name).to eq new_attributes[:name]
          expect(node_module.updated_by).to eq(admin.uid)
          assert_jsonapi_response(:ok, node_module, NodeModuleSerializer)
          assert_response_does_not_have_included_relationships
          assert_presence_of_relationships(
            parsed_response['data'], %w[media items nodes]
          )
        end
        it 'updates the requested node_module with listed flag' do
          put :update, params: { id: node_module, listed: false }

          node_module.reload
          expect(node_module.listed).to eq false
          assert_jsonapi_response(:ok, node_module, NodeModuleSerializer)
        end
      end
      context 'adding items to node_module' do
        before do
          @entities = parents_for(node_module)
          @items = create_related_list(:item)
          @item_ids = @items.map(&:id)
          MeSalva::Permalinks::Builder.new(
            entity_id: @entities[:node].parent.id,
            entity_class: 'Node'
          ).build_subtree_permalinks
          assert_permalink_build_worker_call('NodeModule',
                                             node_module.id)
        end
        it 'should define position for every item' do
          node_module.item_ids = @item_ids
          put :update, params: {
            id: node_module, item_ids_order: @item_ids.reverse
          }

          assert_relationship_inclusion_and_ordering(node_module)
          assert_response_related_entity_ids('items', @item_ids.reverse)
        end
        it 'creates a permalink for each item' do
          put :update, params: { id: node_module, item_ids: @item_ids.reverse }

          MeSalva::Permalinks::Builder.new(
            entity_id: node_module.id,
            entity_class: 'NodeModule'
          ).build_subtree_permalinks
          @items.each do |item|
            assert_permalink_inclusion(item.permalinks.first, [
                                         @entities[:education_segment]
                                           .permalinks,
                                         @entities[:node].permalinks,
                                         node_module.permalinks
                                       ])
            assert_permalink_entities_inclusion(
              item.permalinks.first,
              node: [@entities[:education_segment].id, @entities[:node].id],
              node_module: node_module.id,
              item: item.id,
              medium: nil
            )
            expect(item.permalinks.first.slug).to eq slug_for(
              [
                @entities[:education_segment],
                @entities[:node],
                node_module,
                item
              ]
            )
          end
        end
      end

      it_should_behave_like 'a removable related entity',
                            [{ self: :node_module, related: :node },
                             { self: :node_module, related: :item },
                             { self: :node_module, related: :medium }]

      context 'with invalid params' do
        it 'returns http code 422 unprocessable_entity' do
          put :update, params: { id: node_module, name: '' }

          expect(response).to have_http_status(:unprocessable_entity)
        end
      end
      it_behaves_like 'controller #update with inactive "has_many" relations',
                      entity: :node_module, relations: %i[node item medium]
    end

    context 'as user' do
      it_behaves_like 'unauthorized http status for user' do
        let(:name) { 'other node module' }
        let(:id) { 'node_module' }
      end

      context 'when sending platform_id' do
        before { user_session }
        let!(:platform) { create(:platform) }
        let!(:user_platform) do
          create(:user_platform,
                 user_id: user.id,
                 platform_id: platform.id,
                 role: "student")
        end
        let(:parent_node_mesalva) { create(:node) }
        let(:parent_node_platform) { create(:node, platform_id: platform.id) }

        it 'cannot update platform nodes' do
          put :update, params: { id: node_module.id,
                                 name: 'some other name',
                                 node_ids: [parent_node_platform.id],
                                 platform_id: platform.id }
          expect(response).to have_http_status(:unauthorized)
        end

        it 'cannot update a node under the mesalva node' do
          put :update, params: { id: node_module.id,
                                 name: 'some other name',
                                 node_ids: [parent_node_mesalva.id],
                                 platform_id: platform.id }
          expect(response).to have_http_status(:unauthorized)
        end
      end
    end

    context 'as platform admin' do
      before { user_platform_admin_session }
      let(:platform) { user_platform_admin.platform }
      let(:parent_node_mesalva) { create(:node) }
      let(:parent_node_platform) { create(:node, platform_id: platform.id) }

      it 'can update a node under the platform node' do
        put :update, params: { id: node_module.id,
                               name: 'some other name',
                               node_ids: [parent_node_platform.id] }

        expect(response).to have_http_status(:ok)
      end

      it 'cannot update a node under the mesalva node' do
        put :update, params: { id: node_module.id,
                               name: 'some other name',
                               node_ids: [parent_node_mesalva.id] }
        expect(response).to have_http_status(:unauthorized)
      end
    end
  end

  describe 'DELETE #destroy' do
    it_behaves_like 'a destroyed request' do
      let(:id) { node_module }
      let(:model) { NodeModule }
    end
  end
end
